### This file was generated by Nexus Schema
### Do not make changes to this file directly


type BatchPayload {
  count: Int!
}

input BooleanFilter {
  equals: Boolean
  not: Boolean
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type Mutation {
  bigRedButton: String
  createNewOneProduct(name: String): Product
  createOnePpl(data: PplCreateInput!): Ppl!
  createOneProduct(data: ProductCreateInput!): Product!
  deleteManyPpl(where: PplWhereInput): BatchPayload!
  deleteManyProduct(where: ProductWhereInput): BatchPayload!
  deleteOnePpl(where: PplWhereUniqueInput!): Ppl
  deleteOneProduct(where: ProductWhereUniqueInput!): Product
  removeAllProducts: String
  removeProductById(id: ID): Product
  updateManyPpl(data: PplUpdateManyMutationInput!, where: PplWhereInput): BatchPayload!
  updateManyProduct(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  updateOnePpl(data: PplUpdateInput!, where: PplWhereUniqueInput!): Ppl
  updateOneProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateProductById(id: ID, name: String): Product
}

type Ppl {
  email: String!
  id: String!
  password: String!
  role: String!
  status: Boolean!
  username: String!
}

input PplCreateInput {
  email: String!
  id: String!
  password: String!
  role: String!
  status: Boolean
  username: String!
}

input PplUpdateInput {
  email: String
  id: String
  password: String
  role: String
  status: Boolean
  username: String
}

input PplUpdateManyMutationInput {
  email: String
  id: String
  password: String
  role: String
  status: Boolean
  username: String
}

input PplWhereInput {
  AND: [PplWhereInput!]
  email: StringFilter
  id: StringFilter
  NOT: [PplWhereInput!]
  OR: [PplWhereInput!]
  password: StringFilter
  role: StringFilter
  status: BooleanFilter
  username: StringFilter
}

input PplWhereUniqueInput {
  email: String
  id: String
}

type Product {
  id: String!
  name: String!
}

input ProductCreateInput {
  id: String!
  name: String!
}

input ProductUpdateInput {
  id: String
  name: String
}

input ProductUpdateManyMutationInput {
  id: String
  name: String
}

input ProductWhereInput {
  AND: [ProductWhereInput!]
  id: StringFilter
  name: StringFilter
  NOT: [ProductWhereInput!]
  OR: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: String
}

type Query {
  allProducts(skip: String, take: String): [Product!]
  allUsers: [Ppl!]
  ppl(where: PplWhereUniqueInput!): Ppl
  ppls(after: PplWhereUniqueInput, before: PplWhereUniqueInput, first: Int, last: Int): [Ppl!]!
  product(queryStr: String): [Product!]
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}
