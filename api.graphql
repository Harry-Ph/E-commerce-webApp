### This file was generated by Nexus Schema
### Do not make changes to this file directly


type BatchPayload {
  count: Int!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type Mutation {
  bigRedButton: String
  createOnePpl(data: PplCreateInput!): Ppl!
  createOneProduct(data: ProductCreateInput!): Product!
  deleteManyPpl(where: PplWhereInput): BatchPayload!
  deleteManyProduct(where: ProductWhereInput): BatchPayload!
  deleteOnePpl(where: PplWhereUniqueInput!): Ppl
  deleteOneProduct(where: ProductWhereUniqueInput!): Product
  productMutation: String
  updateManyPpl(data: PplUpdateManyMutationInput!, where: PplWhereInput): BatchPayload!
  updateManyProduct(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  updateOnePpl(data: PplUpdateInput!, where: PplWhereUniqueInput!): Ppl
  updateOneProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
}

type Ppl {
  id: String!
  name: String!
}

input PplCreateInput {
  id: String
  name: String!
}

input PplUpdateInput {
  id: String
  name: String
}

input PplUpdateManyMutationInput {
  id: String
  name: String
}

input PplWhereInput {
  AND: [PplWhereInput!]
  id: StringFilter
  name: StringFilter
  NOT: [PplWhereInput!]
  OR: [PplWhereInput!]
}

input PplWhereUniqueInput {
  id: String
}

type Product {
  id: String!
  name: String!
}

input ProductCreateInput {
  id: String
  name: String!
}

input ProductUpdateInput {
  id: String
  name: String
}

input ProductUpdateManyMutationInput {
  id: String
  name: String
}

input ProductWhereInput {
  AND: [ProductWhereInput!]
  id: StringFilter
  name: StringFilter
  NOT: [ProductWhereInput!]
  OR: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: String
}

type Query {
  allProducts: [Product!]
  allUsers: [Ppl!]
  ppl(where: PplWhereUniqueInput!): Ppl
  ppls(after: PplWhereUniqueInput, before: PplWhereUniqueInput, first: Int, last: Int): [Ppl!]!
  product(queryStr: String): [Product!]
  products(after: ProductWhereUniqueInput, before: ProductWhereUniqueInput, first: Int, last: Int): [Product!]!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}
