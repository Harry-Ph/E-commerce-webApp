"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getReturnTypeName = exports.addComputedInputs = exports.transform = exports.getTransformedDmmf = void 0;
const pagination_1 = require("../pagination");
const DmmfDocument_1 = require("./DmmfDocument");
const utils_1 = require("./utils");
exports.getTransformedDmmf = (photonClientPackagePath, options) => new DmmfDocument_1.DmmfDocument(transform(utils_1.getPhotonDmmf(photonClientPackagePath), options));
const addDefaultOptions = (givenOptions) => (Object.assign({ globallyComputedInputs: {}, paginationStrategy: pagination_1.paginationStrategies.relay }, givenOptions));
function transform(document, options) {
    return {
        datamodel: transformDatamodel(document.datamodel),
        mappings: document.mappings,
        schema: transformSchema(document.schema, addDefaultOptions(options)),
    };
}
exports.transform = transform;
function transformDatamodel(datamodel) {
    return {
        enums: datamodel.enums,
        models: datamodel.models.map((model) => (Object.assign(Object.assign({}, model), { fields: model.fields.map((field) => (Object.assign(Object.assign({}, field), { kind: field.kind === 'object' ? 'relation' : field.kind }))) }))),
    };
}
const paginationArgNames = ['cursor', 'take', 'skip'];
function transformSchema(schema, { globallyComputedInputs, paginationStrategy }) {
    return {
        enums: schema.enums,
        inputTypes: schema.inputTypes.map((_) => transformInputType(_, globallyComputedInputs)),
        outputTypes: schema.outputTypes.map((o) => {
            return Object.assign(Object.assign({}, o), { fields: o.fields.map((f) => {
                    let args = f.args.map(transformArg);
                    const argNames = args.map((a) => a.name);
                    // If this field has pagination
                    if (paginationArgNames.every((paginationArgName) => argNames.includes(paginationArgName))) {
                        args = paginationStrategy.transformDmmfArgs({
                            args,
                            paginationArgNames,
                            field: f,
                        });
                    }
                    return Object.assign(Object.assign({}, f), { args, outputType: Object.assign(Object.assign({}, f.outputType), { type: getReturnTypeName(f.outputType.type) }) });
                }) });
        }),
    };
}
/**
 * Conversion from a Prisma Client arg type to a GraphQL arg type using
 * heuristics. A conversion is needed because GraphQL does not
 * support union types on args, but Photon does.
 */
function transformArg(arg) {
    // FIXME: *Enum*Filter are currently empty
    let inputType = arg.inputType.some((a) => a.kind === 'enum')
        ? arg.inputType[0]
        : arg.inputType.find((a) => a.kind === 'object');
    if (!inputType) {
        inputType = arg.inputType[0];
    }
    return {
        name: arg.name,
        inputType: Object.assign(Object.assign({}, inputType), { type: getReturnTypeName(inputType.type) }),
        // FIXME Why?
        isRelationFilter: undefined,
    };
}
/**
 * Recursively looks for inputs that need a value from globallyComputedInputs
 * and populates them
 */
function addGloballyComputedInputs({ inputType, params, dmmf, data, }) {
    if (Array.isArray(data)) {
        return data.map((value) => addGloballyComputedInputs({
            inputType,
            dmmf,
            params,
            data: value,
        }));
    }
    // Get values for computedInputs corresponding to keys that exist in inputType
    const computedInputValues = Object.keys(inputType.computedInputs).reduce((values, key) => (Object.assign(Object.assign({}, values), { [key]: inputType.computedInputs[key](params) })), {});
    // Combine computedInputValues with values provided by the user, recursing to add
    // global computedInputs to nested types
    return Object.keys(data).reduce((deeplyComputedData, fieldName) => {
        const field = inputType.fields.find((_) => _.name === fieldName);
        const fieldValue = field.inputType.kind === 'object'
            ? addGloballyComputedInputs({
                inputType: dmmf.getInputType(field.inputType.type),
                dmmf,
                params,
                data: data[fieldName],
            })
            : data[fieldName];
        return Object.assign(Object.assign({}, deeplyComputedData), { [fieldName]: fieldValue });
    }, computedInputValues);
}
function addComputedInputs({ dmmf, inputType, locallyComputedInputs, params, }) {
    return Object.assign(Object.assign({}, params.args), { data: Object.assign(Object.assign({}, addGloballyComputedInputs({
            inputType,
            dmmf,
            params,
            data: params.args.data,
        })), Object.entries(locallyComputedInputs).reduce((args, [fieldName, computeFieldValue]) => (Object.assign(Object.assign({}, args), { [fieldName]: computeFieldValue(params) })), {})) });
}
exports.addComputedInputs = addComputedInputs;
function transformInputType(inputType, globallyComputedInputs) {
    const fieldNames = inputType.fields.map((field) => field.name);
    /**
     * Only global computed inputs are removed during schema transform.
     * Resolver level computed inputs are filtered as part of the
     * projecting process. They are then passed to addComputedInputs
     * at runtime so their values can be inferred alongside the
     * global values.
     */
    const globallyComputedInputsInType = Object.keys(globallyComputedInputs).reduce((args, key) => fieldNames.includes(key) ? Object.assign(args, { [key]: globallyComputedInputs[key] }) : args, {});
    return Object.assign(Object.assign({}, inputType), { fields: inputType.fields.filter((field) => !(field.name in globallyComputedInputs)).map(transformArg), computedInputs: globallyComputedInputsInType });
}
/**
 * Make the "return type" property type always be a string. In Photon
 * it is allowed to be a nested structured object but we want only the
 * reference-by-name form.
 *
 */
//
// TODO _why_ is the dmmf like this?
//
// FIXME `any` type because this is used by both outputType and inputType
// and there is currently no generic capturing both ideas.
//
function getReturnTypeName(type) {
    if (typeof type === 'string') {
        return type;
    }
    return type.name;
}
exports.getReturnTypeName = getReturnTypeName;
//# sourceMappingURL=transformer.js.map